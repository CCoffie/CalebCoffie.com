{"version":3,"file":"static/webpack/static/development/pages/index.js.9815c057ff8e383165e8.hot-update.js","sources":["webpack:///./components/consoleHook.js"],"sourcesContent":["import { useState } from \"react\";\r\nimport {consoleData} from \"./consoleData\";\r\n\r\nconst constructConsoleOutput = (numKeyPresses) => {\r\n    const messages = consoleData['messages']\r\n    let output = \"\";\r\n    let currentObjectIndex = 0;\r\n    let currentContentStringIndex = 0;\r\n\r\n    // Function to check if end of messages\r\n    const endOfMessages = () => currentObjectIndex >= messages.length;\r\n\r\n    // Function to handle moving to next message object\r\n    const nextMesssageObject = () => {\r\n        currentObjectIndex++;\r\n        currentContentStringIndex = 0;\r\n\r\n        if (!endOfMessages()) {\r\n            output += '\\n';\r\n            if (messages[currentObjectIndex].startingText) {\r\n                output += messages[currentObjectIndex].startingText;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Function to handle single output messages\r\n    const singleOutput = () => {\r\n        output += messages[currentObjectIndex].content;\r\n        nextMesssageObject()\r\n    }\r\n\r\n    // Function to handle multiple output messages\r\n    const multipleOutput = () => {\r\n        if (currentContentStringIndex+1 > messages[currentObjectIndex].content.length) {\r\n            nextMesssageObject()\r\n        } else {\r\n            output += messages[currentObjectIndex].content[currentContentStringIndex]\r\n            currentContentStringIndex++;\r\n        }\r\n    }\r\n\r\n    // Add the initial startingText if it exists\r\n    if (messages[currentObjectIndex].startingText) {\r\n        output += messages[currentObjectIndex].startingText;\r\n    }\r\n\r\n    // Loop through for each key press and construct output\r\n    for (let i = 0; i < numKeyPresses; i++) {\r\n        // Check for end of messages\r\n        if (endOfMessages()) break;\r\n\r\n        // Single output don't require key presses\r\n        while (!endOfMessages() && messages[currentObjectIndex].outputMethod === \"single\") {\r\n            singleOutput();\r\n        }\r\n\r\n        // Check for end of messages\r\n        if (endOfMessages()) break;\r\n\r\n        // Handle multiple key press content\r\n        if (messages[currentObjectIndex].outputMethod === \"multiple\") {\r\n            multipleOutput();\r\n        }\r\n\r\n        // Check for end of messages\r\n        if (endOfMessages()) break;\r\n\r\n        // Single output don't require key presses\r\n        while (!endOfMessages() && messages[currentObjectIndex].outputMethod === \"single\") {\r\n            singleOutput();\r\n        }\r\n    }\r\n    return output;\r\n}\r\n\r\nexport const consoleInput = (initialValue, initialKeyPresses) => {\r\n  const [value, setValue] = useState(initialValue);\r\n  const [numKeyPresses, setNumKeyPresses] = useState(initialKeyPresses);\r\n\r\n  return {\r\n    value,\r\n    setValue,\r\n    numKeyPresses,\r\n    setNumKeyPresses,\r\n    reset: () => {\r\n        setValue(initialValue);\r\n        setNumKeyPresses(0);\r\n    },\r\n    bind: {\r\n      value,\r\n      onKeyPress: (event) => {\r\n          setValue(constructConsoleOutput(numKeyPresses+1));\r\n          setNumKeyPresses(numKeyPresses+1);\r\n      }\r\n    }\r\n  };\r\n};"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AATA;AAiBA;;;;A","sourceRoot":""}